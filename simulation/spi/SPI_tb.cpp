#include <stdio.h>
#include <iostream>
#include <iomanip>
#include <cstdint>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VTop.h"
// Needed for the exposed public fields via "*verilator public*"
// and Top module
// #include "VTop___024unit.h"
#include "VTop__Syms.h"

// Test bench files
#include "module.h"

bool assertionFailure = false;

// ------------------------------------------------------------
// Misc
// ------------------------------------------------------------
int step(int timeStep, TESTBENCH<VTop> *tb, VTop *top)
{
    tb->eval();
    tb->dump(timeStep);

    timeStep++;

    if (timeStep % 10 == 0)
        top->r_Clk ^= 1;

    return timeStep;
}

int assertReset(int timeStep, int duration, TESTBENCH<VTop> *tb, VTop *top)
{
    top->r_Rst_L = 0;
    while (timeStep < duration)
    {
        timeStep = step(timeStep, tb, top);
    }
    top->r_Rst_L = 1;

    return timeStep;
}

bool sendSingleByte(VTop *top, uint8_t data, int clk, int p_clk, int p_tx_rdy, int edgeCnt)
{
    // Look for rising edge
    if (p_clk == 0 && clk == 1 && edgeCnt == 0)
    {
        top->r_Master_TX_Byte = data;
        // Pulse Data-Valid signal for 1 clock
        top->r_Master_TX_DV = 1;
        return true;
    }

    // Look for rising edge
    if (p_clk == 0 && clk == 1 && edgeCnt == 1)
    {
        top->r_Master_TX_DV = 0;
        return true;
    }

    // Look for rising edge of TX ready signal
    if (p_tx_rdy == 0 && top->w_Master_TX_Ready == 1 && edgeCnt == 2)
    {
        return true;
    }

    return false; // event not triggered
}

// This file is similar to a Verilog test bench file except
// is C++
int main(int argc, char *argv[])
{
    Verilated::commandArgs(argc, argv);

    // initialize Verilog (aka SystemVerilog) module
    TESTBENCH<VTop> *tb = new TESTBENCH<VTop>();

    tb->setup();

    VTop *top = tb->core();

    vluint64_t timeStep = 0;
    int duration = 0;

    top->r_Rst_L = 1;
    top->r_Clk = 0;
    int p_r_Clk = top->r_Clk;

    int p_tx_rdy = top->w_Master_TX_Ready;

    // Allow any initial blocks to execute
    tb->eval();
    timeStep++;

    duration = 20;
    while (timeStep < duration)
    {
        timeStep = step(timeStep, tb, top);
    }

    // ---------------------------------------------
    // Perform reset
    // ---------------------------------------------
    duration = 100 + duration;
    timeStep = assertReset(timeStep, duration, tb, top);

    // ---------------------------------------------
    // Send a Byte "C1" = 8'b1100_0001
    // ---------------------------------------------
    // duration = 1600;
    int edgeCnt = 0;
    // while (timeStep < duration)
    while (edgeCnt < 3)
    {
        bool edgeDetected = sendSingleByte(top, 0xC1, top->r_Clk, p_r_Clk, p_tx_rdy, edgeCnt);
        if (edgeDetected)
            edgeCnt++;

        p_r_Clk = top->r_Clk;
        p_tx_rdy = top->w_Master_TX_Ready;

        timeStep = step(timeStep, tb, top);
    }
    std::cout << "timeStep: " << timeStep << std::endl;

    // duration = 100 + timeStep;
    // while (timeStep < duration)
    // {
    //     timeStep = step(timeStep, tb, top);
    // }

    edgeCnt = 0;
    while (edgeCnt < 3)
    {
        bool edgeDetected = sendSingleByte(top, 0xC2, top->r_Clk, p_r_Clk, p_tx_rdy, edgeCnt);
        if (edgeDetected)
            edgeCnt++;

        p_r_Clk = top->r_Clk;
        p_tx_rdy = top->w_Master_TX_Ready;

        timeStep = step(timeStep, tb, top);
    }

    // duration = 100 + timeStep;
    // while (timeStep < duration)
    // {
    //     timeStep = step(timeStep, tb, top);
    // }

    // edgeCnt = 0;
    // while (edgeCnt < 3)
    // {
    //     bool edgeDetected = sendSingleByte(top, 0xEF, top->r_Clk, p_r_Clk, p_tx_rdy, edgeCnt);
    //     if (edgeDetected)
    //         edgeCnt++;

    //     p_r_Clk = top->r_Clk;
    //     p_tx_rdy = top->w_Master_TX_Ready;

    //     timeStep = step(timeStep, tb, top);
    // }

    duration = 100 + timeStep;
    while (timeStep < duration)
    {
        timeStep = step(timeStep, tb, top);
    }

    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--
    std::cout << "Edges detected: " << edgeCnt << std::endl;
    std::cout << "Finish TB." << std::endl;
    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--

    tb->shutdown();

    delete tb;

    exit(EXIT_SUCCESS);
}
