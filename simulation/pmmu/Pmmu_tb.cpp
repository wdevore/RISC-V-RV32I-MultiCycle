#include <stdio.h>
#include <iostream>
#include <iomanip>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VPmmu.h"

// Needed for the exposed public fields via "*verilator public*"
// and Top module
#include "VPmmu___024root.h"
#include "VPmmu__Syms.h"

// Test bench files
#include "module.h"

bool assertionFailure = false;

// ------------------------------------------------------------
// Misc
// ------------------------------------------------------------
extern void dumpMem(VPmmu_Memory *bram);
extern unsigned long int wordToByteAddr(unsigned long int wordaddr);
extern int step(int timeStep, TESTBENCH<VPmmu> *tb, VPmmu___024root *top);
extern void abort(TESTBENCH<VPmmu> *tb);

// ------------------------------------------------------------
// ----- Unsigned load operations
// ------------------------------------------------------------
extern int iType_lbu_byte4(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lbu_byte3(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lbu_byte2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lbu_byte1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lhu_word2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lhu_word1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);

// ************************************************************
// ------ Signed load operations
// ************************************************************

extern int iType_lw_addr0x0A(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lb_byte1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lb_byte2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lh_word2_addr_d18(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int iType_lh_word2_addr_d19(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);

// ************************************************************
// ------ Store operations
// ************************************************************

extern int sType_sw(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int sType_sh_word1(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int sType_sh_word2(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int sType_sb_byte1(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int sType_sb_byte2(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int sType_sb_byte3(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int sType_sb_byte4(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);
extern int sType_sh_single_cycle(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb);

// ------------------------------------------------------------
// This file is similar to a Verilog test bench file except is C++
// ------------------------------------------------------------
int main(int argc, char *argv[])
{
    Verilated::commandArgs(argc, argv);

    // initialize Verilog (aka SystemVerilog) module
    TESTBENCH<VPmmu> *tb = new TESTBENCH<VPmmu>();

    tb->setup();

    VPmmu *vmmu = tb->core();
    VPmmu___024root *top = vmmu->rootp;

    // Direct Pmmu access
    VPmmu_Pmmu *pmmu = vmmu->Pmmu;
    VPmmu_Memory *bram = pmmu->bram;
    // Note: access to other fields uses the __PVT__xxx format
    // bram->__PVT__wr_i = 0;

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // Starting defaults
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    top->wd_i = 0x00000000;   // No meaningful data
    top->funct3 = 0b000; // No instruction (invalid)
    top->mwr_i = 1;           // Disable writing/storing
    top->mrd_i = 1;           // Disable reading/loading
    top->clk_i = 0;           // Default clock level

    vluint64_t timeStep = 0;

    int duration = 20;
    int baseTime = 10;

    // Allow any initial blocks to execute so we can dump memory
    tb->eval();

    dumpMem(bram);

    timeStep = iType_lbu_byte4(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lbu_byte3(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lbu_byte2(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lbu_byte1(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lhu_word2(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lhu_word1(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lw_addr0x0A(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lb_byte1(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lb_byte2(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lh_word2_addr_d18(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lh_word2_addr_d19(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sw(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    // The duration needs to be longer to handle the read+write requirements
    duration = 40;
    baseTime += duration;
    timeStep = sType_sh_word1(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sh_word2(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte1(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte2(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte3(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte4(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    std::cout << "Running to duration" << std::endl;
    int testDuration = timeStep + 25;
    while (timeStep < testDuration)
    {
        timeStep = step(timeStep, tb, top);
    }

    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--
    std::cout << "Finish TB." << std::endl;
    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--
    dumpMem(bram);

    tb->shutdown();

    delete tb;

    exit(EXIT_SUCCESS);
}
