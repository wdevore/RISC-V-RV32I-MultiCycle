#include <stdio.h>
#include <iostream>
#include <iomanip>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VPmmu.h"

// Needed for the exposed public fields via "*verilator public*"
// and Top module
#include "VMemory___024root.h"
#include "VPmmu__Syms.h"

// Test bench files
#include "module.h"

bool assertionFailure = false;

// ------------------------------------------------------------
// Misc
// ------------------------------------------------------------
void dumpMem(VPmmu_Memory *bram)
{
    std::cout << std::setfill('0') << std::hex;
    for (size_t i = 0; i < 20; i++)
    {
        vluint32_t data = bram->mem[i];
        std::cout << "Memory[" << std::setw(2) << i << "] = 0x" << std::setw(8) << std::uppercase << data << std::endl;
    }
}

unsigned long int wordToByteAddr(unsigned long int wordaddr)
{
    return wordaddr * 4;
}

int step(int timeStep, TESTBENCH<VPmmu> *tb, VPmmu___024root *top)
{
    tb->eval();
    tb->dump(timeStep);

    timeStep++;

    if (timeStep % 10 == 0)
        top->clk_i ^= 1;

    return timeStep;
}

void abort(TESTBENCH<VPmmu> *tb)
{
    tb->shutdown();

    delete tb;

    exit(EXIT_FAILURE);
}

// ------------------------------------------------------------
// ----- Unsigned load operations
// ------------------------------------------------------------
int iType_lbu_byte4(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 4th byte = 0x55
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // rd = M[rs1+imm][0:7]
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000101000   10000   100     10011    0000011
    // Nibbles: 0000_0010_1000_1000_0100_1001_1000_0011
    // Word 0x0000000A = 0x0000_0000_0000_0000_0000_0000_0000_1010
    // Byte              0x0000_0000_0000_0000_0000_0000_0010_1000
    // Imm 0000_0010_1000 = 0x028
    // Simulate the immediate calculation x16+0x00A word-address
    // Convert word-addr 0x00A = d40 to byte-addr = 0x00A * 4 = 0x028 = 0b00101000
    // byte selector = 2`b11 = 4th byte

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b11;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }
        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x55)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x55, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lbu_byte3(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 3rd byte = 0xAA
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // rd = M[rs1+imm][0:7]
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000101000   10000   100     10011    0000011
    // Nibbles: 0000_0010_1000_1000_0100_1001_1000_0011
    // Word 0x0000000A = 0x0000_0000_0000_0000_0000_0000_0000_1010
    // Byte              0x0000_0000_0000_0000_0000_0000_0010_1000
    // Imm 0000_0010_1000 = 0x028
    // Simulate the immediate calculation x16+0x00A word-address
    // Convert word-addr 0x00A = d40 to byte-addr = 0x00A * 4 = 0x028 = 0b00101000
    // byte selector = 2`b11 = 4th byte

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xAA)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xAA, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lbu_byte2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 2nd byte = 0x33
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // --**--**--**--**--**--**--**--**--**--**--**--**--**

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b01;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x33)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x3, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lbu_byte1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 1st byte = 0x12
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // --**--**--**--**--**--**--**--**--**--**--**--**--**

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b00;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x12)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x12, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lhu_word2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load lowest halfword(0) from word-address D
    //     rd   rs1   imm
    // lhu x19, x16, 0x00D    x16 = 0     D*4 = 34
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000110100   10000   101     10011    0000011
    // 0000 0011 0100 1000 0101 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x03485983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b00;
            imm = 0x0000000D;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }
        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x6626)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x6626, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lhu_word1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load highest halfword(1) from word-address E
    //     rd   rs1   imm
    // lhu x19, x16, 0x00E    x16 = 4     (A+4)*4 = 0x38
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000111000   10000   101     10011    0000011
    //       |
    //       \----- = 0x038
    // 0000 0011 1000 1000 0101 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x03885983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10; // select high halfword
            rs1 = 4;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xBBAA)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xBBAA, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

// ************************************************************
// ------ Signed load operations
// ************************************************************

int iType_lw_addr0x0A(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load word from word-address 0x000000000010
    //     rd   rs1   imm
    // lw x19, x16,  d16    x16 = 0     (d16)*4 = 0x40
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001000000   10000   010     10011    0000011
    //       |
    //       \----- = 0x040
    // 0000 0100 0000 1000 0010 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x04082983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 0;
            imm = 0x00000010;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x21113456)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x21113456, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lb_byte1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 1st byte and interpret as signed
    // from word-address d17
    // 90 is a negative number = One filled.
    //     rd   rs1   imm
    // lb x19, x16, 0x...011    x16 = 0     (d17)*4 = 0x44
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001000100   10000   000     10011    0000011
    //       |
    //       \----- = 0x044
    // 0000 0100 0100 1000 0000 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x04480983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b00; // select low byte
            rs1 = 0;
            imm = 0x00000011;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xFFFFFF90)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xFFFFFF90, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lb_byte2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 2nd byte and interpret as signed
    // from word-address d18
    //     rd   rs1   imm
    // lb x19, x16,  d18    x16 = 0     (d18)*4 = 0x48
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001001000   10000   000     10011    0000011
    //       |
    //       \----- = 0x048
    // 0000 0100 1000 1000 0000 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x04880983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b01; // select byte 2
            rs1 = 0;
            imm = 0x00000012;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xFFFFFFA0)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xFFFFFFA0, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lh_word2_addr_d18(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load high halfword(1) and interpret as signed. Data is negative
    // from word-address d18
    //     rd   rs1   imm
    // lh x19, x16,  d18    x16 = 0     (d18)*4 = 0x48
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001001000   10000   001     10011    0000011
    //       |
    //       \----- = 0x048
    // 0000 0010 1100 1000 0001 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x04881983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10; // select high halfword
            rs1 = 0;
            imm = 0x00000012;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xFFFFD0B0)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xFFFFD0B0, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lh_word2_addr_d19(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load high halfword(1) and interpret as signed. Data is positive
    // from word-address d19
    //     rd   rs1   imm
    // lh x19, x16,  d19    x16 = 0     (d19)*4 = 0x52
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001010010   10000   001     10011    0000011
    //       |
    //       \----- = 0x052
    // 0000 0010 1100 1000 0001 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x05281983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10; // select high halfword
            rs1 = 0;
            imm = 0x00000013;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x1AB0)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x1AB0, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

// ************************************************************
// ------ Store operations
// ************************************************************

int sType_sw(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // S-Type: Store word to word-address d4
    //    rs2   rs1 = x2 = 4
    // sw x14, 1(x2)    imm(x2) = 1(4)*(4 bytes) = d16
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:5   |  rs2 |  rs1 |  funct3 |  imm4:0 |  opcode
    //    0000000     01110  00010    010      00001     0100011
    //       |                                   |
    //        \----------- = 0x01 --------------/
    //   0    0    E    1   2     0    A   3
    // 0000 0000 1110 0001 0010 0000 1010 0011

    unsigned long int rs1 = 0;
    unsigned long int rs2 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x00E120A3;
            top->mwr_i = 1; // Disable writing/storing
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b00; // not relevant for words
            rs1 = 4;
            rs2 = 0x0B0A0908; // The data to write
            imm = 0x00000001;
            top->wd_i = rs2;
            top->byte_addr_i = wordToByteAddr(imm * rs1) + selector;
        }

        if (timeStep == baseTime + 8)
        {
            top->mwr_i = 0; // Enable writing/storing
        }

        if (timeStep == baseTime + 15)
        {
            top->mwr_i = 1; // Disable writing/storing
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    int cell = bram->mem[imm * rs1];
    if (cell != 0x0B0A0908)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected BRAM[4] = 0x0B0A0908, got: " << std::hex << cell << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int sType_sh_word1(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // S-Type: Store half-word(0) to word-address d5
    //    rs2   rs1 = x2 = 5
    // sh x14, 1(x2)    imm(x2) = 1(5)*(4 bytes)
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:5   |  rs2 |  rs1 |  funct3 |  imm4:0 |  opcode
    //    0000000     01110  00010    001      00001     0100011
    //       |                                   |
    //        \----------- = 0x01 --------------/
    //   0    0    E    1   1     0    A   3
    // 0000 0000 1110 0001 0001 0000 1010 0011

    unsigned long int rs1 = 0;
    unsigned long int rs2 = 0; // x14 -- just for description.
    unsigned long int imm = 0;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x00E110A3;
            top->mwr_i = 1; // Disable writing/storing
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 5;
            rs2 = 0xAABBCCDD; // The data to write. Only CCDD should be written
            imm = 0x00000001;
            top->wd_i = rs2;
            top->mrd_i = 0; // Enable reading
            top->byte_addr_i = wordToByteAddr(imm * rs1);
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading
        }

        if (timeStep == baseTime + 25)
        {
            top->mwr_i = 0; // Enable writing/storing
        }

        if (timeStep == baseTime + 35)
        {
            top->mwr_i = 1; // Disable writing/storing
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    int cell = bram->mem[imm * rs1];
    if (cell != 0x1111CCDD)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected BRAM[4] = 0x1111CCDD, got: " << std::hex << cell << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int sType_sh_word2(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // S-Type: Store half-word(0) to word-address d5 to upper word
    //    rs2   rs1 = x2 = 5
    // sh x14, 1(x2)    imm(x2) = 1(5)*(4 bytes)
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:5   |  rs2 |  rs1 |  funct3 |  imm4:0 |  opcode
    //    0000000     01110  00010    001      00001     0100011
    //       |                                   |
    //        \----------- = 0x01 --------------/
    //   0    0    E    1   1     0    A   3
    // 0000 0000 1110 0001 0001 0000 1010 0011

    unsigned long int rs1 = 0;
    unsigned long int rs2 = 0; // x14 -- just for description.
    unsigned long int imm = 0;
    assertionFailure = false;
    int selector = 0;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x00E110A3;
            top->mwr_i = 1; // Disable writing/storing
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 5;
            rs2 = 0xAABB7788; // The data to write. Only 7788 should be written
            imm = 0x00000001;
            selector = 0b10;
            top->wd_i = rs2;
            top->mrd_i = 0; // Enable reading
            top->byte_addr_i = wordToByteAddr(imm * rs1) + selector;
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading
        }

        if (timeStep == baseTime + 25)
        {
            top->mwr_i = 0; // Enable writing/storing
        }

        if (timeStep == baseTime + 35)
        {
            top->mwr_i = 1; // Disable writing/storing
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    int cell = bram->mem[imm * rs1];
    if (cell != 0x7788CCDD)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected BRAM[4] = 0x7788CCDD, got: " << std::hex << cell << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int sType_sb_byte1(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // S-Type: Store 1st byte to word-address d8
    //    rs2   rs1 = x2 = 8
    // sb x14, 1(x2)    imm(x2) = 1(8)*(4 bytes)
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:5   |  rs2 |  rs1 |  funct3 |  imm4:0 |  opcode
    //    0000000     01110  00010    000      00001     0100011
    //       |                                   |
    //        \----------- = 0x01 --------------/
    //   0    0    E    1   0     0    A   3
    // 0000 0000 1110 0001 0000 0000 1010 0011

    unsigned long int rs1 = 0;
    unsigned long int rs2 = 0; // x14 -- just for description.
    unsigned long int imm = 0;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x00E100A3;
            top->mwr_i = 1; // Disable writing/storing
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 8;
            rs2 = 0xAABBCCDD; // The data to write. Only DD should be written
            imm = 0x00000001;
            top->wd_i = rs2;
            top->mrd_i = 0; // Enable reading
            top->byte_addr_i = wordToByteAddr(imm * rs1);
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading
        }

        if (timeStep == baseTime + 25)
        {
            top->mwr_i = 0; // Enable writing/storing
        }

        if (timeStep == baseTime + 35)
        {
            top->mwr_i = 1; // Disable writing/storing
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    int cell = bram->mem[imm * rs1];
    if (cell != 0x111111DD)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected BRAM[4] = 0x111111DD, got: " << std::hex << cell << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int sType_sb_byte2(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // S-Type: Store byte to word-address d8 2nd byte position
    //    rs2   rs1 = x2 = 8
    // sb x14, 1(x2)    imm(x2) = 1(8)*(4 bytes)
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:5   |  rs2 |  rs1 |  funct3 |  imm4:0 |  opcode
    //    0000000     01110  00010    000      00001     0100011
    //       |                                   |
    //        \----------- = 0x01 --------------/
    //   0    0    E    1   0     0    A   3
    // 0000 0000 1110 0001 0000 0000 1010 0011

    unsigned long int rs1 = 0;
    unsigned long int rs2 = 0; // x14 -- just for description.
    unsigned long int imm = 0;
    assertionFailure = false;
    int selector = 0;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x00E100A3;
            top->mwr_i = 1; // Disable writing/storing
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 8;
            rs2 = 0x111111CC; // The byte to write. Only CC should be written
            imm = 0x00000001;
            selector = 0b01;
            top->wd_i = rs2;
            top->mrd_i = 0; // Enable reading
            top->byte_addr_i = wordToByteAddr(imm * rs1) + selector;
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading
        }

        if (timeStep == baseTime + 25)
        {
            top->mwr_i = 0; // Enable writing/storing
        }

        if (timeStep == baseTime + 35)
        {
            top->mwr_i = 1; // Disable writing/storing
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    int cell = bram->mem[imm * rs1];
    if (cell != 0x1111CCDD)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected BRAM[4] = 0x1111CCDD, got: " << std::hex << cell << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int sType_sb_byte3(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // S-Type: Store byte to word-address d8 3rd byte position
    //    rs2   rs1 = x2 = 8
    // sb x14, 1(x2)    imm(x2) = 1(8)*(4 bytes)
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:5   |  rs2 |  rs1 |  funct3 |  imm4:0 |  opcode
    //    0000000     01110  00010    000      00001     0100011
    //       |                                   |
    //        \----------- = 0x01 --------------/
    //   0    0    E    1   0     0    A   3
    // 0000 0000 1110 0001 0000 0000 1010 0011

    unsigned long int rs1 = 0;
    unsigned long int rs2 = 0; // x14 -- just for description.
    unsigned long int imm = 0;
    assertionFailure = false;
    int selector = 0;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x00E100A3;
            top->mwr_i = 1; // Disable writing/storing
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 8;
            rs2 = 0x11111133; // The byte to write. Only 33 should be written
            imm = 0x00000001;
            selector = 0b10;
            top->wd_i = rs2;
            top->mrd_i = 0; // Enable reading
            top->byte_addr_i = wordToByteAddr(imm * rs1) + selector;
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading
        }

        if (timeStep == baseTime + 25)
        {
            top->mwr_i = 0; // Enable writing/storing
        }

        if (timeStep == baseTime + 35)
        {
            top->mwr_i = 1; // Disable writing/storing
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    int cell = bram->mem[imm * rs1];
    if (cell != 0x1133CCDD)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected BRAM[4] = 0x1133CCDD, got: " << std::hex << cell << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int sType_sb_byte4(int timeStep, int baseTime, int duration, VPmmu_Memory *bram, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // S-Type: Store byte to word-address d8 4th byte position
    //    rs2   rs1 = x2 = 8
    // sb x14, 1(x2)    imm(x2) = 1(8)*(4 bytes)
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:5   |  rs2 |  rs1 |  funct3 |  imm4:0 |  opcode
    //    0000000     01110  00010    000      00001     0100011
    //       |                                   |
    //        \----------- = 0x01 --------------/
    //   0    0    E    1   0     0    A   3
    // 0000 0000 1110 0001 0000 0000 1010 0011

    unsigned long int rs1 = 0;
    unsigned long int rs2 = 0; // x14 -- just for description.
    unsigned long int imm = 0;
    assertionFailure = false;
    int selector = 0;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x00E100A3;
            top->mwr_i = 1; // Disable writing/storing
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 8;
            rs2 = 0x11111144; // The byte to write. Only 44 should be written
            imm = 0x00000001;
            selector = 0b11;
            top->wd_i = rs2;
            top->mrd_i = 0; // Enable reading
            top->byte_addr_i = wordToByteAddr(imm * rs1) + selector;
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading
        }

        if (timeStep == baseTime + 25)
        {
            top->mwr_i = 0; // Enable writing/storing
        }

        if (timeStep == baseTime + 35)
        {
            top->mwr_i = 1; // Disable writing/storing
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    int cell = bram->mem[imm * rs1];
    if (cell != 0x4433CCDD)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected BRAM[4] = 0x4433CCDD, got: " << std::hex << cell << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

// ------------------------------------------------------------
// This file is similar to a Verilog test bench file except is C++
// ------------------------------------------------------------
int main(int argc, char *argv[])
{
    Verilated::commandArgs(argc, argv);

    // initialize Verilog (aka SystemVerilog) module
    TESTBENCH<VPmmu> *tb = new TESTBENCH<VPmmu>();

    tb->setup();

    VPmmu *vmmu = tb->core();
    VPmmu___024root *top = vmmu->rootp;

    // Direct Pmmu access
    VPmmu_Pmmu *pmmu = vmmu->Pmmu;
    VPmmu_Memory *bram = pmmu->bram;
    // Note: access to other fields uses the __PVT__xxx format
    // bram->__PVT__wr_i = 0;

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // Starting defaults
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    top->wd_i = 0x00000000; // No meaningful data
    top->ir_i = 0x00000000; // No instruction (invalid)
    top->mwr_i = 1;         // Disable writing/storing
    top->mrd_i = 1;         // Disable reading/loading
    top->clk_i = 0;         // Default clock level

    vluint64_t timeStep = 0;

    int duration = 20;
    int baseTime = 20;

    // Allow any initial blocks to execute so we can dump memory
    tb->eval();

    dumpMem(bram);

    timeStep = iType_lbu_byte4(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lbu_byte3(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lbu_byte2(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lbu_byte1(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lhu_word2(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lhu_word1(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lw_addr0x0A(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lb_byte1(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lb_byte2(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lh_word2_addr_d18(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = iType_lh_word2_addr_d19(timeStep, baseTime, duration, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sw(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    // The duration needs to be longer to handle the read+write requirements
    duration = 40;
    baseTime += duration;
    timeStep = sType_sh_word1(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sh_word2(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte1(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte2(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte3(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    baseTime += duration;
    timeStep = sType_sb_byte4(timeStep, baseTime, duration, bram, top, tb);
    if (assertionFailure)
        abort(tb);

    std::cout << "Running to duration" << std::endl;
    int testDuration = timeStep + 25;
    while (timeStep < testDuration)
    {
        timeStep = step(timeStep, tb, top);
    }

    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--
    std::cout << "Finish TB." << std::endl;
    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--
    dumpMem(bram);

    tb->shutdown();

    delete tb;

    exit(EXIT_SUCCESS);
}
