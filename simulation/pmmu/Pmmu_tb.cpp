#include <stdio.h>
#include <iostream>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VPmmu.h"

// Needed for the exposed public fields via "*verilator public*"
// and Top module
#include "VMemory___024root.h"
#include "VPmmu__Syms.h"

// Test bench files
#include "module.h"

void tick(VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    top->clk_i = 0;
    tb->eval();
    tb->dump(tb->tick());
}

void tock(VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    top->clk_i = 1;
    tb->eval();
    tb->dump(tb->tick());
}

void clock(VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    tick(top, tb);
    tock(top, tb);
}

unsigned long int wordToByteAddr(unsigned long int wordaddr) {
    return wordaddr * 4;
}

// This file is similar to a Verilog test bench file except
// is C++
int main(int argc, char *argv[])
{
    Verilated::commandArgs(argc, argv);

    // initialize Verilog (aka SystemVerilog) module
    TESTBENCH<VPmmu> *tb = new TESTBENCH<VPmmu>();

    tb->setup();

    tb->show();

    VPmmu *vmmu = tb->core();
    VPmmu___024root *top = vmmu->rootp;

    // Direct Pmmu access
    VPmmu_Pmmu *pmmu = vmmu->Pmmu;
    VPmmu_Memory *bram = pmmu->bram;
    // bram->__PVT__wr_i = 0;

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // Starting defaults
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    top->ir_i = 0x00000000; // No instruction (invalid)
    top->mwr_i = 1;         // Disable writing/storing
    clock(top, tb);

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load lowest byte(0)
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // rd = M[rs1+imm][0:7]
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000101000   10000   100     10011    0000011
    // Nibbles: 0000_0010_1000_1000_0100_1001_1000_0011
    // Word 0x0000000A = 0x0000_0000_0000_0000_0000_0000_0000_1010
    // Byte              0x0000_0000_0000_0000_0000_0000_0010_1000
    // Imm 0000_0010_1000 = 0x028
    // Simulate the immediate calculation x16+0x00A word-address
    // Convert word-addr 0x00A = d40 to byte-addr = 0x00A * 4 = 0x028 = 0b00101000
    // byte selector = 2`b00 = 1st byte = 0x12
    top->ir_i = 0x02884983;
    top->addr_i = wordToByteAddr(0x0000000A) + 3;  // 3rd byte = 0x55
    top->wd_i = 0x00000000;
    top->mrd_i = 0;         // Enable reading/loading

    clock(top, tb);

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load lowest byte(1)
    //     rd   rs1   imm
    // lbu x19, x16, 0x00B    x16 = 0
    // rd = M[rs1+imm][0:7]
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    top->ir_i = 0x02884983;
    top->addr_i = wordToByteAddr(0x0000000B) + 1; // 2nd byte = 0x99
    top->wd_i = 0x00000000;
    top->mrd_i = 0;         // Enable reading/loading

    clock(top, tb);

    std::cout << "F TB: time (" << tb->time() << ")" << std::endl;
    clock(top, tb);
    clock(top, tb);

    tb->shutdown();

    delete tb;

    exit(EXIT_SUCCESS);
}
