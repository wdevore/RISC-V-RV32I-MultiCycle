#include <stdio.h>
#include <iostream>
#include <iomanip>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VPmmu.h"
// Needed for the exposed public fields via "*verilator public*"
// and Top module
#include "VMemory___024root.h"
#include "VPmmu__Syms.h"

// Test bench files
#include "module.h"

extern bool assertionFailure;
extern unsigned long int wordToByteAddr(unsigned long int wordaddr);
extern int step(int timeStep, TESTBENCH<VPmmu> *tb, VPmmu___024root *top);

int iType_lbu_byte4(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 4th byte = 0x55
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // rd = M[rs1+imm][0:7]
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000101000   10000   100     10011    0000011
    // Nibbles: 0000_0010_1000_1000_0100_1001_1000_0011
    // Word 0x0000000A = 0x0000_0000_0000_0000_0000_0000_0000_1010
    // Byte              0x0000_0000_0000_0000_0000_0000_0010_1000
    // Imm 0000_0010_1000 = 0x028
    // Simulate the immediate calculation x16+0x00A word-address
    // Convert word-addr 0x00A = d40 to byte-addr = 0x00A * 4 = 0x028 = 0b00101000
    // byte selector = 2`b11 = 4th byte

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b11;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }
        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x55)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x55, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lbu_byte3(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 3rd byte = 0xAA
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // rd = M[rs1+imm][0:7]
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000101000   10000   100     10011    0000011
    // Nibbles: 0000_0010_1000_1000_0100_1001_1000_0011
    // Word 0x0000000A = 0x0000_0000_0000_0000_0000_0000_0000_1010
    // Byte              0x0000_0000_0000_0000_0000_0000_0010_1000
    // Imm 0000_0010_1000 = 0x028
    // Simulate the immediate calculation x16+0x00A word-address
    // Convert word-addr 0x00A = d40 to byte-addr = 0x00A * 4 = 0x028 = 0b00101000
    // byte selector = 2`b11 = 4th byte

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xAA)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xAA, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lbu_byte2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 2nd byte = 0x33
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // --**--**--**--**--**--**--**--**--**--**--**--**--**

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b01;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x33)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x3, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lbu_byte1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 1st byte = 0x12
    //     rd   rs1   imm
    // lbu x19, x16, 0x00A    x16 = 0
    // --**--**--**--**--**--**--**--**--**--**--**--**--**

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x02884983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b00;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x12)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x12, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lhu_word2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load lowest halfword(0) from word-address D
    //     rd   rs1   imm
    // lhu x19, x16, 0x00D    x16 = 0     D*4 = 34
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000110100   10000   101     10011    0000011
    // 0000 0011 0100 1000 0101 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x03485983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b00;
            imm = 0x0000000D;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }
        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x6626)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x6626, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lhu_word1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load highest halfword(1) from word-address E
    //     rd   rs1   imm
    // lhu x19, x16, 0x00E    x16 = 4     (A+4)*4 = 0x38
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000000111000   10000   101     10011    0000011
    //       |
    //       \----- = 0x038
    // 0000 0011 1000 1000 0101 1001 1000 0011

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep <= baseTime + duration)
    {
        if (timeStep - 1 == baseTime)
        {
            top->ir_i = 0x03885983;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10; // select high halfword
            rs1 = 4;
            imm = 0x0000000A;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xBBAA)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xBBAA, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}
