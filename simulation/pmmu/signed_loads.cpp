#include <stdio.h>
#include <iostream>
#include <iomanip>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VPmmu.h"
// Needed for the exposed public fields via "*verilator public*"
// and Top module
#include "VPmmu___024root.h"
#include "VPmmu__Syms.h"

// Test bench files
#include "module.h"

extern bool assertionFailure;
extern unsigned long int wordToByteAddr(unsigned long int wordaddr);
extern int step(int timeStep, TESTBENCH<VPmmu> *tb, VPmmu___024root *top);

int iType_lw_addr0x0A(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load word from word-address 0x000000000010
    // lw => rd = M[rs1+imm][0:31]
    //     rd  rs1 imm
    // lw x19, x0, d16    x16 = 0     (d16)*4 = 0x40
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001000000   00000   010     10011    0000011
    //       |
    //       \----- = 0x040
    // 0000 0100 0000 0000 0010 1001 1000 0011 = 0x04002983

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep < baseTime + duration)
    {
        if (timeStep == baseTime)
        {
            top->funct3 = 0b010;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            rs1 = 0;
            imm = 0x00000010;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x21113456)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x21113456, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lb_byte1(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 1st byte and interpret as signed
    // from word-address d17
    // 90 is a negative number = One filled.
    //     rd   rs1   imm
    // lb x19, x16, 0x...011    x16 = 0     (d17)*4 = 0x44
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001000100   10000   000     10011    0000011
    //       |
    //       \----- = 0x044
    // 0000 0100 0100 1000 0000 1001 1000 0011 = 0x04480983

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep < baseTime + duration)
    {
        if (timeStep == baseTime)
        {
            top->funct3 = 0b000;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b00; // select low byte
            rs1 = 0;
            imm = 0x00000011;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xFFFFFF90)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xFFFFFF90, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lb_byte2(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load 2nd byte and interpret as signed
    // from word-address d18
    //     rd   rs1   imm
    // lb x19, x16,  d18    x16 = 0     (d18)*4 = 0x48
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001001000   10000   000     10011    0000011
    //       |
    //       \----- = 0x048
    // 0000 0100 1000 1000 0000 1001 1000 0011 = 0x04880983

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep < baseTime + duration)
    {
        if (timeStep == baseTime)
        {
            top->funct3 = 0b000;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b01; // select byte 2
            rs1 = 0;
            imm = 0x00000012;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xFFFFFFA0)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xFFFFFFA0, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lh_word2_addr_d18(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load high halfword(1) and interpret as signed. Data is negative
    // from word-address d18
    //     rd   rs1   imm
    // lh x19, x16,  d18    x16 = 0     (d18)*4 = 0x48
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001001000   10000   001     10011    0000011
    //       |
    //       \----- = 0x048
    // 0000 0010 1100 1000 0001 1001 1000 0011 = 0x04881983

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep < baseTime + duration)
    {
        if (timeStep == baseTime)
        {
            top->funct3 = 0b001;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10; // select high halfword
            rs1 = 0;
            imm = 0x00000012;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0xFFFFD0B0)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0xFFFFD0B0, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}

int iType_lh_word2_addr_d19(int timeStep, int baseTime, int duration, VPmmu___024root *top, TESTBENCH<VPmmu> *tb)
{
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // I-Type: Load high halfword(1) and interpret as signed. Data is positive
    // from word-address d19
    //     rd   rs1   imm
    // lh x19, x16,  d19    x16 = 0     (d19)*4 = 0x52
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //    imm11:0   |  rs1 | funct3 |   rd  |  opcode
    // 000001010010   10000   001     10011    0000011
    //       |
    //       \----- = 0x052
    // 0000 0010 1100 1000 0001 1001 1000 0011 = 0x05281983

    unsigned long int rs1 = 0;
    unsigned long int imm = 0;
    int selector = 0b00;
    assertionFailure = false;

    while (timeStep < baseTime + duration)
    {
        if (timeStep == baseTime)
        {
            top->funct3 = 0b001;
            top->mrd_i = 1; // Disable reading/loading
        }

        if (timeStep == baseTime + 5)
        {
            selector = 0b10; // select high halfword
            rs1 = 0;
            imm = 0x00000013;
            top->byte_addr_i = wordToByteAddr(rs1 + imm) + selector;
            top->mrd_i = 0; // Enable reading/loading
        }

        if (timeStep == baseTime + 15)
        {
            top->mrd_i = 1; // Disable reading/loading
        }

        timeStep = step(timeStep, tb, top);
    }

    // Test assertion
    if (top->rd_o != 0x1AB0)
    {
        std::cout << "###########################################" << std::endl;
        std::cout << "# expected rd_o = 0x1AB0, got: " << top->rd_o << std::endl;
        std::cout << "###########################################" << std::endl;
        assertionFailure = true;
    }

    return timeStep;
}
