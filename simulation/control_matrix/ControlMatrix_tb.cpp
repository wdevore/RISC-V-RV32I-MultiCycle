#include <stdio.h>
#include <iostream>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VControlMatrix.h"
// Needed for the exposed public fields via "*verilator public*"
#include "VControlMatrix___024unit.h"
#include "VControlMatrix__Syms.h"

// Test bench files
#include "module.h"

void tick(VControlMatrix___024root *top, TESTBENCH<VControlMatrix> *tb)
{
    top->clk_i = 0;
    tb->eval();
    tb->dump(tb->tick());
}

void tock(VControlMatrix___024root *top, TESTBENCH<VControlMatrix> *tb)
{
    top->clk_i = 1;
    tb->eval();
    tb->dump(tb->tick());
}

void clock(VControlMatrix___024root *top, TESTBENCH<VControlMatrix> *tb)
{
    tick(top, tb);
    tock(top, tb);
}

// This file is similar to a Verilog test bench file except
// is C++
int main(int argc, char *argv[])
{
    Verilated::commandArgs(argc, argv);

    // initialize Verilog (aka SystemVerilog) module
    TESTBENCH<VControlMatrix> *tb = new TESTBENCH<VControlMatrix>();

    tb->setup();

    tb->show();

    VControlMatrix *vcm = tb->core();

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // Not recommended. This will give you a separate instance.
    // You want the module's instance that is used for simulation. >------------|
    // VControlMatrix___024unit *cmU = new VControlMatrix___024unit("cmU");     |
    //                                                                          |
    // This XXX___024unit has any publicly exposed constructs                   |
    // --**--**--**--**--**--**--**--**--**--**--**--**--**                     |
    VControlMatrix___024unit *const cmU = vcm->__PVT____024unit; // <--------/
    VControlMatrix___024root *top = vcm->rootp;
    VControlMatrix_ControlMatrix *cm = vcm->ControlMatrix;

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    // Starting defaults
    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    top->mem_busy_i = 0;    // Memory is ready (i.e. not busy)
    top->ir_i = 0x00000000; // No instruction (invalid)

    top->reset_i = 0;
    clock(top, tb);       // hold reset low for 2 clocks
    clock(top, tb);
    top->reset_i = 1;


    // cm->state = cmU->MatrixState::Reset;

    // cmU->ALU_Ops::SraOp
    // std::cout << "state: " << cm->state << std::endl;

    // --**--**--**--**--**--**--**--**--**--**--**--**--**
    //
    // --**--**--**--**--**--**--**--**--**--**--**--**--**

    // Padding
    std::cout << "TB reset complete" << std::endl;
    clock(top, tb);
    std::cout << "TB fetch" << std::endl;
    top->ir_i = 0x000000A0;
    clock(top, tb);
    clock(top, tb);
    clock(top, tb);
    clock(top, tb);
    clock(top, tb);
    std::cout << "F TB: time (" << tb->time() << ")" << std::endl;

    std::cout << "TB: time (" << tb->time() << ")" << std::endl;
    tb->shutdown();

    delete tb;

    exit(EXIT_SUCCESS);
}
