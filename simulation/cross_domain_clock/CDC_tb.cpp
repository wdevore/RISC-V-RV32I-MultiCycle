#include <stdio.h>
#include <iostream>
#include <iomanip>
#include <cstdint>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VTop.h"
// Needed for the exposed public fields via "*verilator public*"
// and Top module
// #include "VTop___024unit.h"
#include "VTop__Syms.h"

// Test bench files
#include "module.h"

bool assertionFailure = false;

// ------------------------------------------------------------
// Misc
// ------------------------------------------------------------
int step(int timeStep, TESTBENCH<VTop> *tb, VTop *top)
{
    tb->eval();
    tb->dump(timeStep);

    timeStep++;

    if (timeStep % 10 == 0)
        top->sysClk_i ^= 1;

    return timeStep;
}

// This file is similar to a Verilog test bench file except
// is C++
int main(int argc, char *argv[])
{
    Verilated::commandArgs(argc, argv);

    // initialize Verilog (aka SystemVerilog) module
    TESTBENCH<VTop> *tb = new TESTBENCH<VTop>();

    tb->setup();

    VTop *top = tb->core();

    vluint64_t timeStep = 0;
    int duration = 0;

    top->sysClk_i = 0;
    top->async_i = 0;

    // Allow any initial blocks to execute
    tb->eval();
    timeStep++;

    duration = 500;
    while (timeStep < duration)
    {
        // Signal occurs before rising edge, thus missed
        if (timeStep == 32)
        {
            top->async_i = 1;
        }
        if (timeStep == 42)
        {
            top->async_i = 0;
        }

        // A short signal
        if (timeStep == 105)
        {
            top->async_i = 1;
        }
        if (timeStep == 119)
        {
            top->async_i = 0;
        }

        // Longer signal
        if (timeStep == 105+150)
        {
            top->async_i = 1;
        }
        if (timeStep == 129+150)
        {
            top->async_i = 0;
        }

        // Longest signal
        if (timeStep == 105+250)
        {
            top->async_i = 1;
        }
        if (timeStep == 180+250)
        {
            top->async_i = 0;
        }

        timeStep = step(timeStep, tb, top);
    }

    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--
    std::cout << "Finish TB." << std::endl;
    // :--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--:--

    tb->shutdown();

    delete tb;

    exit(EXIT_SUCCESS);
}
