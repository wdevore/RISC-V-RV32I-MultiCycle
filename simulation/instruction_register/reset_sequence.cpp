#include <stdio.h>
#include <iostream>
#include <iomanip>

// Files generated by Verilator
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "VIRModule.h"
// Needed for the exposed public fields via "*verilator public*"
// and Top module
#include "VIRModule___024unit.h"
#include "VIRModule__Syms.h"

// Test bench files
#include "module.h"

extern bool assertionFailure;
extern unsigned long int wordToByteAddr(unsigned long int wordaddr);
extern int step(int timeStep, TESTBENCH<VIRModule> *tb, VIRModule___024root *top);

int reset_sequence(int timeStep, int baseTime, int duration,
                   TESTBENCH<VIRModule> *tb,
                   VIRModule___024root *top,
                   VIRModule_IRModule *const irm,
                   VIRModule___024unit *const unit)
{
    assertionFailure = false;
    using namespace std;

    // The sub-modules
    VIRModule_ControlMatrix *cm = irm->matrix;
    VIRModule_Register *ir = irm->ir;

    cm->__PVT__mem_busy_i = 0;    // Memory is ready (i.e. not busy)
    cm->__PVT__ir_i = 0x00000000; // No instruction (invalid)

    cout << "(" << timeStep << ") to (" << (baseTime + duration) << ") Reset TB begin." << endl;

    // 0 -> 55
    while (timeStep <= baseTime + duration)
    {
        tb->eval();

        if (timeStep - 1 == baseTime)
        {
            top->reset_i = 0;
        }

        // When reach end of duration deactivate reset signal
        if (timeStep == baseTime + duration)
        {
            top->reset_i = 1;
            cout << "(" << timeStep << ") End Reset state." << endl;
            break;
        }

        timeStep = step(timeStep, tb, top);
    }

    int currentStep = timeStep - 1;

    // Verilator note: There are two ways you can access non-top-modules variables:
    // Publicly (explicit) or Privately (implicit).
    // Public access requires you use the "/*verilator public*/" Directive,
    // for example: MatrixState vector_state /*verilator public*/;
    //
    // Private access is easier/lazier but requires you know the "prefix"
    // for example: cm->__PVT__vector_state, where the prefix is "__PVT__".
    //
    // You can NOT use them both. Using the Directive "removes" the private
    // definition, and leaving the Directive out "removes" the public definition.
    //
    // I tend to use the Directive as shown below.
    if (cm->vector_state != unit->ResetState::Vector0)
    {
        cout << "###########################################" << endl;
        cout << "# (" << currentStep << ") expected Vector0 reached" << endl;
        cout << "###########################################" << endl;
        assertionFailure = true;
    }

    if (cm->next_vector_state != unit->ResetState::Vector1)
    {
        cout << "###########################################" << endl;
        cout << "# (" << currentStep << ") expected next_vector_state=Vector1 " << endl;
        cout << "###########################################" << endl;
        assertionFailure = true;
    }

    // Once we exit reset state the output flags should activate
    if (cm->resetComplete == 1)
    {
        cout << "###########################################" << endl;
        cout << "# (" << currentStep << ") expected resetComplete=1, got: " << cm->resetComplete << endl;
        cout << "###########################################" << endl;
        assertionFailure = true;
    }

    if (cm->ready == 1)
    {
        cout << "###########################################" << endl;
        cout << "# (" << currentStep << ") expected ready=1, got: " << cm->ready << endl;
        cout << "###########################################" << endl;
        assertionFailure = true;
    }

    cout << "--- Reset TB complete at " << timeStep << " ---" << endl;
    return timeStep;
}
